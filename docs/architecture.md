# アーキテクチャ概要

rabbit-rtc はゲーム配信のための Web アプリケーションであり、配信者と視聴者のクライアント間で低遅延の映像・音声ストリーミングを実現することを目的としています。MVP ではブラウザからのライブ配信と視聴にフォーカスし、コメント機能やユーザー管理は後続のバックログとして扱います。

## コンポーネント構成

| コンポーネント | 技術スタック | 役割 |
| --- | --- | --- |
| フロントエンド | TypeScript / React | UI、WebRTC メディア取得、シグナリングの送受信 |
| バックエンド API & シグナリング | Go (Echo などのWebフレームワークを想定) | ユーザー管理（将来的に）、セッション管理、シグナリング、設定配布 |
| WebRTC メディア処理 | Go (`pion/webrtc` など) | ピア接続の確立、メディアストリームの中継（初期は配信者→視聴者のメッシュ想定） |
| データストア | TBD（Redis / PostgreSQL など必要に応じて） | セッション情報やメタデータの格納（MVPでは最小構成） |

> **メモ**: 学習用途のため、まずは配信者1名・視聴者複数名のシナリオを想定し、負荷対策よりも仕組みの理解を優先します。将来的には SFU の導入や TURN サーバ構築を検討できます。

## シグナリングと通信フロー
1. 配信者がフロントエンドから配信開始をリクエスト。
2. フロントエンドがカメラ・マイクを取得し、WebRTC Offer を生成。
3. WebSocket 経由でバックエンドのシグナリングサーバへ Offer を送信。
4. バックエンドが配信セッションを生成し、視聴者に向けて Offer/Answer を中継。
5. ICE 候補が交換され、ピア接続が確立。
6. 視聴者側のフロントエンドは受信したメディアストリームを再生。

## レイテンシ要件
- 目標: 0.3〜0.8 秒程度の往復遅延。
- 許容上限: 1.5 秒程度。ネットワーク状態が悪い場合でも 2〜3 秒以内に収める。
- チューニング指針: 解像度・ビットレート設定、コーデック選択（VP8/H.264 など）、ICE サーバ構成を調整。

## スケーラビリティと今後の検討
- 同時接続数は 10 名程度を想定し、配信者側のアップロード負荷を考慮したメッシュ構成からスタート。
- ユーザー数増加や安定性向上が必要となったタイミングで SFU の導入や TURN サーバ構築を検討。
- コメント機能や録画機能は別途バックエンド拡張（データベース、ストレージ）が必要。

## デプロイ構成 (Vercel + Fly.io)

- **フロントエンド**: Vercel に React ビルドをデプロイし、HTTPS とCDNを自動化。
- **バックエンド**: Fly.io に Go 製シグナリング/メディア制御サーバをデプロイ。`fly deploy` によりコンテナを簡単に更新。
- **TURN サーバ**: Fly.io 上で `coturn` を別アプリとして稼働させ、ブラウザへ ICE 設定を配布。
- **DNS / ドメイン**: Vercel ドメイン管理を使うか、既存のDNSにCNAMEを追加して統一。

> 小規模構成で運用負荷を抑えつつ、将来的にAWS等へ移行する余地を残す構成。
